// WARNING: this file is auto-generated by xtask gen and may be overwritten

use super::*;


/// The IO was completed by a filter.
pub const IO_COMPLETE : HResultSuccess = HResultSuccess::from_constant(0x001F0001); // ERROR_FLT_IO_COMPLETE

/// A handler was not defined by the filter for this operation.
pub const NO_HANDLER_DEFINED : HResultError = HResultError::from_constant(0x801F0001); // ERROR_FLT_NO_HANDLER_DEFINED

/// A context is already defined for this object.
pub const CONTEXT_ALREADY_DEFINED : HResultError = HResultError::from_constant(0x801F0002); // ERROR_FLT_CONTEXT_ALREADY_DEFINED

/// Asynchronous requests are not valid for this operation.
pub const INVALID_ASYNCHRONOUS_REQUEST : HResultError = HResultError::from_constant(0x801F0003); // ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST

/// Disallow the Fast IO path for this operation.
pub const DISALLOW_FAST_IO : HResultError = HResultError::from_constant(0x801F0004); // ERROR_FLT_DISALLOW_FAST_IO

/// An invalid name request was made. The name requested cannot be retrieved at this time.
pub const INVALID_NAME_REQUEST : HResultError = HResultError::from_constant(0x801F0005); // ERROR_FLT_INVALID_NAME_REQUEST

/// Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock.
pub const NOT_SAFE_TO_POST_OPERATION : HResultError = HResultError::from_constant(0x801F0006); // ERROR_FLT_NOT_SAFE_TO_POST_OPERATION

/// The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver.
pub const NOT_INITIALIZED : HResultError = HResultError::from_constant(0x801F0007); // ERROR_FLT_NOT_INITIALIZED

/// The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called).
pub const FILTER_NOT_READY : HResultError = HResultError::from_constant(0x801F0008); // ERROR_FLT_FILTER_NOT_READY

/// The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers.
pub const POST_OPERATION_CLEANUP : HResultError = HResultError::from_constant(0x801F0009); // ERROR_FLT_POST_OPERATION_CLEANUP

/// The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.
pub const INTERNAL_ERROR : HResultError = HResultError::from_constant(0x801F000A); // ERROR_FLT_INTERNAL_ERROR

/// The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.
pub const DELETING_OBJECT : HResultError = HResultError::from_constant(0x801F000B); // ERROR_FLT_DELETING_OBJECT

/// Non-paged pool must be used for this type of context.
pub const MUST_BE_NONPAGED_POOL : HResultError = HResultError::from_constant(0x801F000C); // ERROR_FLT_MUST_BE_NONPAGED_POOL

/// A duplicate handler definition has been provided for an operation.
pub const DUPLICATE_ENTRY : HResultError = HResultError::from_constant(0x801F000D); // ERROR_FLT_DUPLICATE_ENTRY

/// The callback data queue has been disabled.
pub const CBDQ_DISABLED : HResultError = HResultError::from_constant(0x801F000E); // ERROR_FLT_CBDQ_DISABLED

/// Do not attach the filter to the volume at this time.
pub const DO_NOT_ATTACH : HResultError = HResultError::from_constant(0x801F000F); // ERROR_FLT_DO_NOT_ATTACH

/// Do not detach the filter from the volume at this time.
pub const DO_NOT_DETACH : HResultError = HResultError::from_constant(0x801F0010); // ERROR_FLT_DO_NOT_DETACH

/// An instance already exists at this altitude on the volume specified.
pub const INSTANCE_ALTITUDE_COLLISION : HResultError = HResultError::from_constant(0x801F0011); // ERROR_FLT_INSTANCE_ALTITUDE_COLLISION

/// An instance already exists with this name on the volume specified.
pub const INSTANCE_NAME_COLLISION : HResultError = HResultError::from_constant(0x801F0012); // ERROR_FLT_INSTANCE_NAME_COLLISION

/// The system could not find the filter specified.
pub const FILTER_NOT_FOUND : HResultError = HResultError::from_constant(0x801F0013); // ERROR_FLT_FILTER_NOT_FOUND

/// The system could not find the volume specified.
pub const VOLUME_NOT_FOUND : HResultError = HResultError::from_constant(0x801F0014); // ERROR_FLT_VOLUME_NOT_FOUND

/// The system could not find the instance specified.
pub const INSTANCE_NOT_FOUND : HResultError = HResultError::from_constant(0x801F0015); // ERROR_FLT_INSTANCE_NOT_FOUND

/// No registered context allocation definition was found for the given request.
pub const CONTEXT_ALLOCATION_NOT_FOUND : HResultError = HResultError::from_constant(0x801F0016); // ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND

/// An invalid parameter was specified during context registration.
pub const INVALID_CONTEXT_REGISTRATION : HResultError = HResultError::from_constant(0x801F0017); // ERROR_FLT_INVALID_CONTEXT_REGISTRATION

/// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
pub const NAME_CACHE_MISS : HResultError = HResultError::from_constant(0x801F0018); // ERROR_FLT_NAME_CACHE_MISS

/// The requested device object does not exist for the given volume.
pub const NO_DEVICE_OBJECT : HResultError = HResultError::from_constant(0x801F0019); // ERROR_FLT_NO_DEVICE_OBJECT

/// The specified volume is already mounted.
pub const VOLUME_ALREADY_MOUNTED : HResultError = HResultError::from_constant(0x801F001A); // ERROR_FLT_VOLUME_ALREADY_MOUNTED

/// The specified Transaction Context is already enlisted in a transaction
pub const ALREADY_ENLISTED : HResultError = HResultError::from_constant(0x801F001B); // ERROR_FLT_ALREADY_ENLISTED

/// The specified context is already attached to another object
pub const CONTEXT_ALREADY_LINKED : HResultError = HResultError::from_constant(0x801F001C); // ERROR_FLT_CONTEXT_ALREADY_LINKED

/// No waiter is present for the filter's reply to this message.
pub const NO_WAITER_FOR_REPLY : HResultError = HResultError::from_constant(0x801F0020); // ERROR_FLT_NO_WAITER_FOR_REPLY

/// The filesystem database resource is in use. Registration cannot complete at this time.
pub const REGISTRATION_BUSY : HResultError = HResultError::from_constant(0x801F0023); // ERROR_FLT_REGISTRATION_BUSY

/// The filter is not allowed to attach because it has not declared compability with WCOS.
pub const WCOS_NOT_SUPPORTED : HResultError = HResultError::from_constant(0x801F0024); // ERROR_FLT_WCOS_NOT_SUPPORTED

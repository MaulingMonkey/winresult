use crate::scan;



pub fn codes(codes: &scan::Codes) {
    let types = "ErrorCode HResultError HResultSuccess HResult NtStatus ErrorHResultOrCode";

    let _ = std::fs::create_dir_all("crates/winresult/src/gen/codes/ERROR");

    for (rs_mod, codes) in codes.mods.iter() {
        let path = format!("crates/winresult/src/gen/codes/{}.rs", rs_mod.replace("::", "/"));
        mmrbi::fs::write_if_modified_with(path, |rs|{
            use std::io::{Write as _};

            let mut rs = crate::crlf::EolRewriter(rs);

            writeln!(rs, "// WARNING: this file is auto-generated by xtask gen and may be overwritten")?;
            writeln!(rs)?;
            writeln!(rs, "use super::*;")?;
            writeln!(rs)?;
            let mut prev_doc = false;
            for code in codes.iter() {
                #[allow(unused_variables)] let scan::Code { cpp, rs_mod, rs_id, rs_ty, rs_value, docs, redundant, hide, deprecated } = &code;

                if prev_doc || (!hide && !docs.is_empty()) { writeln!(rs)?; }

                if *hide {
                    write!(rs, "#[doc(hidden)] ")?;
                    prev_doc = false;
                } else {
                    for doc in docs.iter() { writeln!(rs, "/// {doc}")?; }
                    prev_doc = !docs.is_empty();
                }
                if let Some(deprecated) = deprecated {
                    write!(rs, "#[deprecated = {deprecated:?}] ")?;
                }
                let rs_value = code.rs_value_nice();
                writeln!(rs, "pub const {rs_id} : {rs_ty} = {rs_ty}::from_constant({rs_value}); // {cpp}")?;
            }

            Ok(())
        }).unwrap();
    }

    let _ = std::fs::create_dir_all("crates/winresult-types/src/gen");
    mmrbi::fs::write_if_modified_with("crates/winresult-types/src/gen/debug.rs", |rs|{
        use std::io::{Write as _};

        let mut rs = crate::crlf::EolRewriter(rs);

        writeln!(rs, "// WARNING: this file is auto-generated by xtask gen and may be overwritten")?;

        writeln!(rs)?;
        writeln!(rs, r#"impl Debug for HResultFacilityMicrosoft {{"#)?;
        writeln!(rs, r#"    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {{"#)?;
        writeln!(rs, r#"        #[allow(unreachable_patterns)] let s = match self.0 {{"#)?;
        {
            macro_rules! microsoft_hresult_facilities {($(
                #define $prefix:ident $f:ident $value:literal
            )*) => {{$(
                let value = $value;
                let cpp = concat!(stringify!($prefix), stringify!($f));
                writeln!(rs, r#"            {value} => "{cpp}","#)?;
            )*}}}
            include!("../../../../../crates/winresult/src/hresult/extra.facilities.rs");
            include!("../../../../../crates/winresult/src/hresult/winerror.facilities.rs");
        }
        writeln!(rs, r#"            v => return write!(fmt, "FACILITY::??? ({{v}})")"#)?;
        writeln!(rs, r#"        }};"#)?;
        writeln!(rs, r#"        write!(fmt, "{{}}", s)"#)?;
        writeln!(rs, r#"    }}"#)?;
        writeln!(rs, r#"}}"#)?;

        writeln!(rs)?;
        writeln!(rs, r#"impl Debug for NtStatusFacilityMicrosoft {{"#)?;
        writeln!(rs, r#"    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {{"#)?;
        writeln!(rs, r#"        #[allow(unreachable_patterns)] let s = match self.0 {{"#)?;
        {
            macro_rules! microsoft_ntstatus_facilities {($(
                #define $prefix:ident $f:ident $value:literal
            )*) => {{$(
                let value = $value;
                let cpp = concat!(stringify!($prefix), stringify!($f));
                writeln!(rs, r#"            {value} => "{cpp}","#)?;
            )*}}}
            include!("../../../../../crates/winresult/src/ntstatus/facilities.rs");
        }
        writeln!(rs, r#"            v => return write!(fmt, "FACILITY::??? ({{v}})")"#)?;
        writeln!(rs, r#"        }};"#)?;
        writeln!(rs, r#"        write!(fmt, "{{}}", s)"#)?;
        writeln!(rs, r#"    }}"#)?;
        writeln!(rs, r#"}}"#)?;

        for ty in types.split(' ') {
            writeln!(rs)?;
            writeln!(rs, r#"impl Debug for {ty} {{"#)?;
            writeln!(rs, r#"    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {{"#)?;
            writeln!(rs, r#"        let s = match self.0 {{"#)?;
            match ty {
                "NtStatus"              => writeln!(rs, r#"            0 => "STATUS::SUCCESS","#)?,
                _                       => {},
            }
            for (_rs_mod, codes) in codes.mods.iter() {
                for code in codes.iter() {
                    if code.redundant { continue }
                    if !code.matches_ty(ty) { continue }
                    #[allow(unused_variables)] let scan::Code { cpp, rs_mod, rs_id, rs_ty, rs_value, docs, redundant, hide, deprecated } = &code;
                    if *hide { continue }
                    let rs_value = code.rs_value_nice();
                    writeln!(rs, r#"            {rs_value} => "{rs_mod}::{rs_id}","#)?;
                }
            }
            match ty {
                "HResult"               => writeln!(rs, r#"            v => return write!(fmt, "HResult({{v:#X}})")"#)?,
                "NtStatus"              => writeln!(rs, r#"            v => return write!(fmt, "NtStatus({{v:#X}})")"#)?,
                "ErrorCode"             => writeln!(rs, r#"            v => return write!(fmt, "ERROR::??? ({{v}})")"#)?,
                "ErrorHResultOrCode"    => writeln!(rs, r#"            v => return write!(fmt, "ERROR::??? ({{v}})")"#)?,
                _                       => writeln!(rs, r#"            v => return write!(fmt, "ERROR::??? ({{v}})")"#)?,
            }
            writeln!(rs, r#"        }};"#)?;
            writeln!(rs, r#"        write!(fmt, "{{}}", s)"#)?;
            writeln!(rs, r#"    }}"#)?;
            writeln!(rs, r#"}}"#)?;
        }

        Ok(())
    }).unwrap();

    mmrbi::fs::write_if_modified_with("crates/winresult/src/errors.natvis", |nv|{
        use std::io::{Write as _};

        let mut nv = crate::crlf::EolRewriter(nv);

        writeln!(nv, r#"<?xml version="1.0" encoding="utf-8"?>"#)?;
        writeln!(nv, r#"<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">"#)?;
        writeln!(nv, r#"    <!-- WARNING: this file is auto-generated by xtask gen and may be overwritten -->"#)?;

        writeln!(nv)?;
        writeln!(nv, r#"    <Type Name="winresult_types::wait::WaitCode">"#)?;
        writeln!(nv, r#"        <DisplayString Condition="(0x00 &lt;= __0) &amp;&amp; (__0 &lt; 0x40)">WAIT::OBJECT_{{__0    - 0x00}}</DisplayString>"#)?;
        writeln!(nv, r#"        <DisplayString Condition="(0x80 &lt;= __0) &amp;&amp; (__0 &lt; 0xC0)">WAIT::ABANDONED_{{__0 - 0x80}}</DisplayString>"#)?;
        writeln!(nv, r#"        <DisplayString Condition="__0 ==       0xC0">WAIT::IO_COMPLETION</DisplayString>"#)?;
        writeln!(nv, r#"        <DisplayString Condition="__0 ==      0x102">WAIT::TIMEOUT</DisplayString>"#)?;
        writeln!(nv, r#"        <DisplayString Condition="__0 == 0xFFFFFFFF">WAIT::FAILED</DisplayString>"#)?;
        writeln!(nv, r#"        <DisplayString>WaitCode({{__0,X}})</DisplayString>"#)?;
        writeln!(nv, r#"    </Type>"#)?;

        writeln!(nv)?;
        writeln!(nv, r#"    <Type Name="winresult_types::hresult::HResultFacilityMicrosoft">"#)?;
        {
            macro_rules! microsoft_hresult_facilities {($(
                #define $prefix:ident $f:ident $value:literal
            )*) => {{$(
                let value = $value;
                let cpp = concat!(stringify!($prefix), stringify!($f));
                writeln!(nv, r#"        <DisplayString Condition="__0 == {value}">{cpp} (HResultFacilityMicrosoft)</DisplayString>"#)?;
            )*}}}
            include!("../../../../../crates/winresult/src/hresult/extra.facilities.rs");
            include!("../../../../../crates/winresult/src/hresult/winerror.facilities.rs");
        }
        writeln!(nv, r#"        <DisplayString>FACILITY_??? ({{__0}})</DisplayString>"#)?;
        writeln!(nv, r#"    </Type>"#)?;

        writeln!(nv)?;
        writeln!(nv, r#"    <Type Name="winresult_types::ntstatus::NtStatusFacilityMicrosoft">"#)?;
        {
            macro_rules! microsoft_ntstatus_facilities {($(
                #define $prefix:ident $f:ident $value:literal
            )*) => {{$(
                let value = $value;
                let cpp = concat!(stringify!($prefix), stringify!($f));
                writeln!(nv, r#"        <DisplayString Condition="__0 == {value}">{cpp} (NtStatusFacilityMicrosoft)</DisplayString>"#)?;
            )*}}}
            include!("../../../../../crates/winresult/src/ntstatus/facilities.rs");
        }
        writeln!(nv, r#"        <DisplayString>FACILITY_??? ({{__0}})</DisplayString>"#)?;
        writeln!(nv, r#"    </Type>"#)?;

        for ty in types.split(' ') {
            writeln!(nv)?;
            match ty {
                "ErrorCode"             => writeln!(nv, r#"    <Type Name="winresult_types::code::{ty}">"#)?,
                "HResult"               => writeln!(nv, r#"    <Type Name="winresult_types::hresult::{ty}">"#)?,
                "HResultSuccess"        => writeln!(nv, r#"    <Type Name="winresult_types::hresult::{ty}">"#)?,
                "HResultError"          => writeln!(nv, r#"    <Type Name="winresult_types::hresult::{ty}">"#)?,
                "NtStatus"              => writeln!(nv, r#"    <Type Name="winresult_types::ntstatus::{ty}">"#)?,
                "ErrorHResultOrCode"    => writeln!(nv, r#"    <Type Name="winresult_types::unions::{ty}">"#)?,
                //_                       => writeln!(nv, r#"    <Type Name="winresult_types::{ty}">"#)?,
                _                       => panic!("expected ty: {ty:?}"),
            }
            match ty {
                "HResult"               => {},
                "HResultSuccess"        => {},
                "HResultError"          => {},
                "NtStatus"              => writeln!(nv, r#"        <DisplayString Condition="__0 == 0">STATUS::SUCCESS</DisplayString>"#)?,
                _                       => {},
            }

            if !"HResult HResultSuccess HResultError".split(' ').any(|t| t == ty) { // don't emit DisplayString codes for HRESULTs, instead leverage <HResult>...</HResult>s with (::HRESULT) casts
                for (_rs_mod, codes) in codes.mods.iter() {
                    for code in codes.iter() {
                        if code.redundant { continue }
                        if !code.matches_ty(ty) { continue }
                        #[allow(unused_variables)] let scan::Code { cpp, rs_mod, rs_id, rs_ty, rs_value, docs, redundant, hide, deprecated } = &code;
                        if *hide { continue }
                        let rs_value = code.rs_value_nice();
                        writeln!(nv, r#"        <DisplayString Condition="__0 == {rs_value}">{rs_mod}::{rs_id}</DisplayString>"#)?;
                    }
                }
            }

            if ty == "ErrorHResultOrCode" {
                writeln!(nv, r#"        <DisplayString Condition="__0 &lt; 0x80000000">{{__0}} ({ty})</DisplayString>"#)?;
            }

            match ty {
                // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/0642cb2f-2075-4469-918c-4441e69c548a
                "HResult" | "HResultSuccess" | "HResultError" | "ErrorHResultOrCode" => {
                    let cond_hr = if ty == "ErrorHResultOrCode" { "(__0 &gt;= 0x80000000)" } else { "true" };

                    writeln!(nv, r#"        <DisplayString>{{(::HRESULT)__0,hr}} ({ty})</DisplayString>"#)?;
                    writeln!(nv, r#"        <Expand>"#)?;
                    writeln!(nv, r#"            <Item Name="S (failure)"  Condition="{cond_hr}">((__0 &amp; 0x80000000) != 0)</Item>"#)?;
                    writeln!(nv, r#"            <Item Name="R (reserved)" Condition="{cond_hr}">((__0 &amp; 0x40000000) != 0)</Item>"#)?;
                    writeln!(nv, r#"            <Item Name="C (customer)" Condition="{cond_hr}">((__0 &amp; 0x20000000) != 0)</Item>"#)?;
                    writeln!(nv, r#"            <Item Name="N (NTSTATUS)" Condition="{cond_hr}">((__0 &amp; 0x10000000) != 0)</Item>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <!-- HRESULT -->"#)?;
                    writeln!(nv, r#"            <Synthetic Name="Facility" Condition="{cond_hr} &amp;&amp; ((__0 &amp; 0x30000000) == 0x00000000)">"#)?;
                    {
                        macro_rules! microsoft_hresult_facilities {($(
                            #define $prefix:ident $f:ident $value:literal
                        )*) => {{$(
                            let value = $value;
                            let cpp = concat!(stringify!($prefix), stringify!($f));
                            writeln!(nv, r#"                <DisplayString Condition="((__0 >> 16) &amp; 0xFFF) == {value}">{cpp}</DisplayString>"#)?;
                        )*}}}
                        include!("../../../../../crates/winresult/src/hresult/extra.facilities.rs");
                        include!("../../../../../crates/winresult/src/hresult/winerror.facilities.rs");
                        writeln!(nv, r#"                <DisplayString>{{(__0 >> 16) &amp; 0xFFF}}</DisplayString>"#)?;
                    }
                    writeln!(nv, r#"            </Synthetic>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <!-- NTSTATUS -->"#)?;
                    writeln!(nv, r#"            <Synthetic Name="Facility" Condition="{cond_hr} &amp;&amp; ((__0 &amp; 0x30000000) == 0x10000000)">"#)?;
                    {
                        macro_rules! microsoft_ntstatus_facilities {($(
                            #define $prefix:ident $f:ident $value:literal
                        )*) => {{$(
                            let value = $value;
                            let cpp = concat!(stringify!($prefix), stringify!($f));
                            writeln!(nv, r#"                <DisplayString Condition="((__0 >> 16) &amp; 0xFFF) == {value}">{cpp}</DisplayString>"#)?;
                        )*}}}
                        include!("../../../../../crates/winresult/src/ntstatus/facilities.rs");
                        writeln!(nv, r#"                <DisplayString>{{(__0 >> 16) &amp; 0xFFF}}</DisplayString>"#)?;
                    }
                    writeln!(nv, r#"            </Synthetic>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <!-- Customer -->"#)?;
                    writeln!(nv, r#"            <Item Name="Facility" Condition="{cond_hr} &amp;&amp; ((__0 &amp; 0x20000000) == 0x20000000)">((__0 &amp; 0x0FFF0000) >>16)</Item>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <Item Name="Code">((__0 &amp; 0x0000FFFF) >> 0)</Item>"#)?;
                    writeln!(nv, r#"            <Item Name="Value" Condition="{cond_hr}">__0,X</Item>"#)?;
                    writeln!(nv, r#"        </Expand>"#)?;
                },
                // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781
                "NtStatus" => {
                    writeln!(nv, r#"        <DisplayString>{{__0,X}} ({ty})</DisplayString>"#)?;
                    writeln!(nv, r#"        <Expand>"#)?;
                    //writeln!(nv, r#"            <Item Name="Sev"         >((__0 &amp; 0xC0000000) >>30)</Item>"#)?;
                    writeln!(nv, r#"            <Synthetic Name="Sev">"#)?;
                    writeln!(nv, r#"                <DisplayString Condition="(__0 >> 30) == 0">STATUS::SEVERITY::SUCCESS</DisplayString>"#)?;
                    writeln!(nv, r#"                <DisplayString Condition="(__0 >> 30) == 1">STATUS::SEVERITY::INFORMATIONAL</DisplayString>"#)?;
                    writeln!(nv, r#"                <DisplayString Condition="(__0 >> 30) == 2">STATUS::SEVERITY::WARNING</DisplayString>"#)?;
                    writeln!(nv, r#"                <DisplayString Condition="(__0 >> 30) == 3">STATUS::SEVERITY::ERROR</DisplayString>"#)?;
                    writeln!(nv, r#"            </Synthetic>"#)?;
                    writeln!(nv, r#"            <Item Name="C (customer)">((__0 &amp; 0x20000000) != 0)</Item>"#)?;
                    writeln!(nv, r#"            <Item Name="N (reserved)">((__0 &amp; 0x10000000) != 0)</Item>"#)?; // "must be set to 0", but surely this is set to 1...? maybe?
                    writeln!(nv)?;
                    writeln!(nv, r#"            <!-- NTSTATUS -->"#)?;
                    writeln!(nv, r#"            <Synthetic Name="Facility" Condition="(__0 &amp; 0x20000000) == 0">"#)?;
                    {
                        macro_rules! microsoft_ntstatus_facilities {($(
                            #define $prefix:ident $f:ident $value:literal
                        )*) => {{$(
                            let value = $value;
                            let cpp = concat!(stringify!($prefix), stringify!($f));
                            writeln!(nv, r#"                <DisplayString Condition="((__0 >> 16) &amp; 0xFFF) == {value}">{cpp}</DisplayString>"#)?;
                        )*}}}
                        include!("../../../../../crates/winresult/src/ntstatus/facilities.rs");
                        writeln!(nv, r#"                <DisplayString>{{(__0 >> 16) &amp; 0xFFF}}</DisplayString>"#)?;
                    }
                    writeln!(nv, r#"            </Synthetic>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <!-- Customer -->"#)?;
                    writeln!(nv, r#"            <Item      Name="Facility" Condition="(__0 &amp; 0x20000000) != 0">((__0 &amp; 0x0FFF0000) >>16)</Item>"#)?;
                    writeln!(nv)?;
                    writeln!(nv, r#"            <Item Name="Code"        >((__0 &amp; 0x0000FFFF) >> 0)</Item>"#)?;
                    writeln!(nv, r#"        </Expand>"#)?;
                },
                "ErrorCode" => {
                    writeln!(nv, r#"        <DisplayString>{{__0}} ({ty})</DisplayString>"#)?;
                },
                _ => {
                },
            }

            writeln!(nv, r#"    </Type>"#)?;
        }

        writeln!(nv)?;
        writeln!(nv, r#"    <!-- HRESULTs -->"#)?;
        for (_rs_mod, codes) in codes.mods.iter() {
            for code in codes.iter() {
                if code.redundant { continue }
                if !code.matches_ty("HResult") { continue }
                #[allow(unused_variables)] let scan::Code { cpp, rs_mod, rs_id, rs_ty, rs_value, docs, redundant, hide, deprecated } = &code;
                if *hide { continue }
                let rs_value = code.rs_value_nice();
                writeln!(nv, r#"    <HResult Name="{cpp}"><HRValue>{rs_value}</HRValue></HResult>"#)?;
                //writeln!(nv, r#"        <HRDescription>No elements in the collection.</HRDescription>"#)?;
            }
        }

        writeln!(nv)?;
        writeln!(nv, r#"</AutoVisualizer>"#)?;

        Ok(())
    }).unwrap();
}

pub fn readme() {
    let winresult_doc_intro_md = std::fs::read_to_string("crates/winresult/doc/intro.md"  ).expect("crates/winresult/doc/intro.md").replace("\r\n", "\n");
    let license_md          = std::fs::read_to_string("LICENSE.md"                  ).expect("LICENSE.md").replace("\r\n", "\n");

    for path in "Readme.md crates/winresult/Readme.md".split(' ') {
        mmrbi::fs::write_if_modified_with(path, |md|{
            use std::io::Write as _;
            let mut md = crate::crlf::EolRewriter(md);
            writeln!(md, "<!-- WARNING: auto generated by xtask gen, this file will be overwritten -->")?;
            writeln!(md)?;
            writeln!(md)?;
            writeln!(md)?;
            writeln!(md, "<!-- crates/winresult/doc/intro.md -->")?;
            writeln!(md)?;
            writeln!(md, "{winresult_doc_intro_md}")?;
            writeln!(md)?;
            writeln!(md)?;
            writeln!(md)?;
            writeln!(md, "<!-- LICENSE.md -->")?;
            writeln!(md)?;
            write!(md, "{license_md}")
        }).unwrap();
    }
}

pub fn licenses() {
    use std::io::Write;
    for file in "LICENSE-APACHE LICENSE-MIT LICENSE.md".split(' ') {
        let text = std::fs::read(file).expect(file);
        for crate_ in "winresult winresult-types".split(' ') {
            let target = format!(r"crates\{crate_}\{file}");
            mmrbi::fs::write_if_modified_with(&target, |f| f.write_all(&text)).unwrap();
        }
    }
}
